
#pragma once

#include <languages/fstrips/formulae.hxx>
#include <problem.hxx>
#include <utils/utils.hxx>
#include <languages/fstrips/utils.hxx>

namespace fs0 { namespace language { namespace fstrips {

//! A number of helper methods to compute and deal with action / formula / term scopes
class LogicalOperations {
public:
	
	
	static Conjunction::cptr conjunction(Conjunction::cptr f1, Conjunction::cptr f2) {
		auto all_subterms = Utils::merge(FStripsUtils::clone(f1->_conjuncts), FStripsUtils::clone(f2->_conjuncts));
		return new Conjunction(all_subterms);
	}
	
	static ExistentiallyQuantifiedFormula::cptr conjunction(ExistentiallyQuantifiedFormula::cptr f1, Conjunction::cptr f2) {
		// We simply return the existentially quantified formula that results from conjuncting the LHS subconjunction with the RHS conjunction, with the same quantified variables.
		return new ExistentiallyQuantifiedFormula(f1->_variables, conjunction(f1->_subformula, f2));
	}
	
	static Formula::cptr conjunction(Conjunction::cptr f1, ExistentiallyQuantifiedFormula::cptr f2) { return conjunction(f2, f1); }
	
	
	//! The conjunction of a tautology with X is always X
	static Conjunction::cptr conjunction(Tautology::cptr f1, Conjunction::cptr f2) { return f2->clone(); }
	static Conjunction::cptr conjunction(const Conjunction& f1, const Tautology& f2) { return f1.clone(); }
	static ExistentiallyQuantifiedFormula::cptr conjunction(Tautology::cptr f1, ExistentiallyQuantifiedFormula::cptr f2) { return f2->clone(); }
	static ExistentiallyQuantifiedFormula::cptr conjunction(ExistentiallyQuantifiedFormula::cptr f1, Tautology::cptr f2) { return f1->clone(); }

	//! The conjunction of a contradiction with anything else is always a contradiction
	static Contradiction::cptr conjunction(Contradiction::cptr f1, Conjunction::cptr f2) { return new Contradiction; }
	static Contradiction::cptr conjunction(Conjunction::cptr f1, Contradiction::cptr f2) { return new Contradiction; }
	static Contradiction::cptr conjunction(Contradiction::cptr f1, ExistentiallyQuantifiedFormula::cptr f2) { return new Contradiction; }
	static Contradiction::cptr conjunction(ExistentiallyQuantifiedFormula::cptr f1, Contradiction::cptr f2) { return new Contradiction; }
	
	//!
	static Formula::cptr conjunction(const Formula& f1, const Formula& f2) {
		
		
		
		throw std::runtime_error("TODO - To implement");
	}
};


inline Formula::cptr operator*(const Conjunction& f1, const Tautology& f2) {
  throw std::runtime_error("TODOOOOOOOOOOOO - To implement");
}

inline Formula::cptr operator*(const Formula& lhs, const Formula& rhs) {
  throw std::runtime_error("TODO - To implement");
}



} } } // namespaces
