
#pragma once

#include <actions.hxx>
#include <fs0_types.hxx>
#include <state.hxx>
#include "constraints/constraint_manager.hxx"

namespace fs0 {

class Problem; class RPGData;

/**
 * An applicability manager operating on a delete-free relaxation of the problem in order to
 * assess the applicability of actions (disregarding state constraints is part of the relaxation).
 *
 * There are two possible ways of checking the applicability of an action:
 * (1) In the simplest case, when all of the action preconditions and effects are at most unary
 *     (effects can be 0-ary, but note that 0-ary preconditions are static and should be detected at compile-time),
 *     we use an exact method implemented by the DirectActionManager.
 *
 * (2) In the general case, i.e. when the above restrictions on the arity of the procedures do not hold,
 *     we use a GecodeActionManager that involves a Gecode model.
 */
class ActionManagerFactory
{
public:
	//! A factory method to create the appropriate manager.
	static BaseActionManager* create(const Problem& problem, const Action& action);
	
	//! Helper to instantiate the manager for all actions in a given vector
	static void instantiate(const Problem& problem, const Action::vcptr& actions);

protected:
	//! Returns true iff at least one of the preconditions of the action has arity higher than one.
	static bool actionHasHigherArityPreconditions(const Action& action);

	//! Returns true iff at least one of the effects of the action has arity higher than one.
	static bool actionHasHigherArityEffects(const Action& action);
};



/**
 * Base interface for an action manager.
 */
class BaseActionManager {
public:
	//!
	BaseActionManager() {};
	virtual ~BaseActionManager() {};

	//! Process the given action in the given layer of the RPG, adding newly-achievable atoms and their supoprts to the rpg data structure.
	virtual void processAction(unsigned actionIdx, const Action& action, const RelaxedState& layer, RPGData& rpg) = 0;
	
	//! Prints a representation of the object to the given stream.
	friend std::ostream& operator<<(std::ostream &os, const BaseActionManager& o) { return o.print(os); }
	virtual std::ostream& print(std::ostream& os) const = 0;
};


/**
 * A constraint manager capable only of dealing with actions whose constraints are all unary,
 * in which case the handling is much simpler and more efficient.
 */
class DirectActionManager : public BaseActionManager
{
public:
	//! Constructs a manager handling the given set of constraints
	DirectActionManager(const Action& action)
		:  BaseActionManager(), manager(action.getConstraints()) {}
	~DirectActionManager() {}

	virtual void processAction(unsigned actionIdx, const Action& action, const RelaxedState& layer, RPGData& rpg);

	//!
	virtual bool checkPreconditionApplicability(const DomainMap& domains) const;

	//!
	void processEffects(unsigned actionIdx, const Action& action, const DomainMap& actionProjection, RPGData& rpg) const;

protected:
	//!
	const ConstraintManager manager;

	//!
	void completeAtomSupport(const VariableIdxVector& actionScope, const DomainMap& actionProjection, const VariableIdxVector& effectScope, Atom::vctrp support) const;
	
	std::ostream& print(std::ostream& os) const;
};


} // namespaces
