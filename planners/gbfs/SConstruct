#
# This SConstruct file is automatically moved to the directory where the generated 
# instance-specific problem data resides during the process of generating the executable solver.
#

import os

HOME = os.path.expanduser("~")

# read variables from the cache, a user's custom.py file or command line arguments
vars = Variables(['variables.cache', 'custom.py'], ARGUMENTS)
vars.Add(BoolVariable('debug', 'Whether this is a debug build', 'no'))
vars.Add(PathVariable('lapkt', 'Path where the LAPKT library is installed', os.getenv('LWAPTKDEV', ''), PathVariable.PathIsDir))
vars.Add(PathVariable('fs0', 'Path where the FS0 library is installed', os.getenv('FS0_PATH', ''), PathVariable.PathIsDir))

env = Environment(variables=vars, ENV=os.environ)

env.Append( CCFLAGS = ['-Wall', '-pedantic', '-std=c++0x' ] )  # Flags common to all options
if int(ARGUMENTS.get('debug', 0)) == 1 :
	env.Append( CCFLAGS = ['-g', '-DDEBUG' ] )
	fs0_libname = 'fs0-debug'
else:
	env.Append( CCFLAGS = ['-O3', '-DNDEBUG' ] )
	fs0_libname = 'fs0'


include_paths = [env['lapkt'] + '/include',
                 env['lapkt'] + '/interfaces/agnostic',
                 env['fs0'] + '/src',
                 '.']

lib_paths = [env['fs0'] + '/lib']

# If we have a local libs on the home directory, use them.
if os.path.exists(HOME + '/local/lib'):
    lib_paths.append(HOME + '/local/lib')
if os.path.exists(HOME + '/local/include'):
    include_paths.append(HOME + '/local/include')
    
env.Append(CPPPATH = [ os.path.abspath(p) for p in include_paths ])

src_objs = [ env.Object(s) for s in Glob('./*.cxx') ] # This will include both the main.cxx and the generated code for the particular instance

env.Append(LIBS=['boost_program_options', fs0_libname])
env.Append(LIBPATH=[ os.path.abspath(p) for p in lib_paths ])

env.Program( 'solver.bin', src_objs )
